PROGRAM BankSimulation;
CONST maxTellers=5;
      arrivalTimeMean=1000;
      serviceTimeMean=1100;
      canvasWidth=800;
      canvasHeight=800;
      maxQueueSize=5;
VAR numTellersPresent,index,curTime,nextArrivalTime,numWaiting: integer;
    tellersPresent: array[0..maxTellers-1] of boolean;
    queueSizes: array[0..maxTellers-1] of integer;
    serviceTimes: array[0..maxTellers-1] of integer;

 procedure calcNextArrivalTime;
 var delta: integer;
 begin
  delta:=arrivalTimeMean-500+random(1000); { range: mean +/- 500 ms }
  nextArrivalTime:=time+delta;
 end;
 
 procedure calcServiceTime(index:integer);
 var delta: integer;
 begin
  delta:=serviceTimeMean-500+random(1000); { range: mean +/- 500 ms }
  serviceTimes[index]:=time+delta;
 end; 

 procedure addTeller(tellerIndex,present: integer);
 var color,x,y: integer;
 begin
  if present=1 then
  begin
   color:=blue;
   tellersPresent[tellerIndex]:=true;
  end
  else
  begin
   color:=silver;
   tellersPresent[tellerIndex]:=false;
  end;

  serviceTimes[tellerIndex]:=0;

  { represent each teller with a blot }
  x:=(tellerIndex)*(canvasWidth/maxTellers)+60;
  y:=60;

  setxy(x,y);
  colour(color);
  blot(40);
 end;

 procedure addCustomer;
 var shortestQueueSize,shortestQueueIndex,color,x,y:integer;
 begin
  shortestQueueSize:=maxQueueSize;
  shortestQueueIndex:=0;
  
  { put the customer at the end of the shortest queue }
  for index:=0 to maxTellers-1 do
  begin
   if tellersPresent[index] and (queueSizes[index]<shortestQueueSize) then
   begin
    shortestQueueIndex:=index;
    shortestQueueSize:=queueSizes[index];
   end;
  end;
  
  queueSizes[shortestQueueIndex]:=queueSizes[shortestQueueIndex]+1;
  
  x:=(shortestQueueIndex)*(canvasWidth/maxTellers)+60;
  y:=queueSizes[shortestQueueIndex]*100+100;

  setxy(x,y);
  colour(green);
  blot(40);

  calcServiceTime(shortestQueueIndex);
  numWaiting:=numWaiting+1;
  writeln('added: '+str(shortestQueueIndex));
 end;
 
 procedure removeCustomer(tellerIndex: integer);
 var x,y: integer;
 begin
  x:=tellerIndex*(canvasWidth/maxTellers)+60;
  y:=queueSizes[tellerIndex]*100+100;
  setxy(x,y);
  colour(white);
  blot(40);

  queueSizes[tellerIndex]:=queueSizes[tellerIndex]-1;
  numWaiting:=numWaiting-1;
  writeln('removed: '+str(tellerIndex));
 end;
 
BEGIN
 canvas(0,0,canvasWidth,canvasHeight);
 resolution(canvasWidth,canvasHeight);
 
 { Init }
 numTellersPresent:=1;
 numWaiting:=0;
 calcNextArrivalTime;
 
 { Create tellers } 
 for index:= 0 to maxTellers-1 do
 begin
  if (index<numTellersPresent) then
  begin
   addTeller(index,1);
  end
  else
  begin
   addTeller(index,0);
  end;
 end;

 { draw line between tellers and customers }
 colour(silver);
 thickness(5);
 setxy(10,130);
 drawxy(canvasWidth-20,0);
 
 { Customer service loop }
 repeat
  noupdate;

  { check time to decide which actions to perform based on that }
  curTime:=time;
  if (curTime>=nextArrivalTime) then
  begin
   addCustomer;
   calcNextArrivalTime;
  end;
   
  for index:=0 to maxTellers-1 do
  begin
   if tellersPresent[index] and (curTime>=serviceTimes[index]) and (queueSizes[index]>0) then
   begin
    removeCustomer(index);
   end;
  end;
     
  writeln('waiting: '+str(numWaiting));
  update;
  pause(200);
 { Until all queues are full }
 until (abs(?key)=\escape) or (numWaiting>=numTellersPresent*maxQueueSize);
END.
