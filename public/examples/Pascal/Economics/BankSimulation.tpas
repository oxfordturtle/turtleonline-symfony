PROGRAM BankSimulation;
CONST maxTellers=5;
      arrivalTimeMean=1000;
      serviceTimeMean=5000;
      canvasWidth=800;
      canvasHeight=800;
      maxQueueSize=5;
VAR numTellersPresent,index,curTime,nextArrivalTime,numWaiting,maxServiceTime: integer;
    tellersPresent: array[0..maxTellers-1] of boolean;
    queueSizes: array[0..maxTellers-1] of integer;
    serviceTimes: array[0..maxTellers-1,0..maxQueueSize] of integer;

 function calcNextArrivalTime: integer;
 var delta: integer;
 begin
  delta:=arrivalTimeMean-500+random(1000); { range: mean +/- 500 ms }
  result:=time+delta;
 end;
 
 function calcServiceTime: integer;
 var delta: integer;
 begin
  delta:=serviceTimeMean-500+random(1000); { range: mean +/- 500 ms }
  result:=time+delta;
 end; 

 procedure addTeller(tellerIndex: integer; present: boolean);
 var color,x,y: integer;
 begin
  if present then
  begin
   color:=blue;
   tellersPresent[tellerIndex]:=true;
  end
  else
  begin
   color:=silver;
   tellersPresent[tellerIndex]:=false;
  end;

  { represent each teller with a blot }
  x:=(tellerIndex)*(canvasWidth/maxTellers)+60;
  y:=60;
  setxy(x,y);
  colour(color);
  blot(40);
 end;

 function addCustomer: integer;
 var shortestQueueSize,shortestQueueIndex,color,x,y,serviceTime:integer;
 begin
  shortestQueueSize:=maxQueueSize;
  shortestQueueIndex:=0;
  
  { put the customer at the end of the shortest queue }
  for index:=0 to maxTellers-1 do
  begin
   if tellersPresent[index] and (queueSizes[index]<shortestQueueSize) then
   begin
    shortestQueueIndex:=index;
    shortestQueueSize:=queueSizes[index];
   end;
  end;
  
  serviceTime:=calcServiceTime;
  serviceTimes[shortestQueueIndex,queueSizes[shortestQueueIndex]]:=serviceTime;
  queueSizes[shortestQueueIndex]:=queueSizes[shortestQueueIndex]+1;
  numWaiting:=numWaiting+1;
  
  x:=(shortestQueueIndex)*(canvasWidth/maxTellers)+60;
  y:=queueSizes[shortestQueueIndex]*100+100;
  setxy(x,y);
  colour(green);
  blot(40);

  writeln('added: '+str(shortestQueueIndex));
  result:=serviceTime;
 end;
 
 procedure removeCustomer(tellerIndex: integer);
 var x,y: integer;
 begin
  x:=tellerIndex*(canvasWidth/maxTellers)+60;
  y:=queueSizes[tellerIndex]*100+100;
  setxy(x,y);
  colour(white);
  blot(40);

  { shift array up by 1 }
  for index:=1 to queueSizes[tellerIndex] do
  begin
   serviceTimes[tellerIndex,index-1]:=serviceTimes[tellerIndex,index];
  end;
   
  queueSizes[tellerIndex]:=queueSizes[tellerIndex]-1;
  numWaiting:=numWaiting-1;
  writeln('removed: '+str(tellerIndex));
 end;
 
BEGIN
 canvas(0,0,canvasWidth,canvasHeight);
 resolution(canvasWidth,canvasHeight);
 
 { Init }
 numTellersPresent:=2;
 numWaiting:=0;
 nextArrivalTime:=calcNextArrivalTime;
 
 { Create tellers } 
 for index:= 0 to maxTellers-1 do
 begin
  if (index<numTellersPresent) then
  begin
   addTeller(index,true);
  end
  else
  begin
   addTeller(index,false);
  end;
 end;

 { draw line between tellers and customers }
 colour(silver);
 thickness(5);
 setxy(10,130);
 drawxy(canvasWidth-20,0);
 
 { Customer service loop }
 repeat
  noupdate;

  { check time to decide which actions to perform based on that }
  curTime:=time;
  if (curTime>=nextArrivalTime) then
  begin
   maxServiceTime:=addCustomer;
   nextArrivalTime:=calcNextArrivalTime;
  end;
   
  for index:=0 to maxTellers-1 do
  begin
   if tellersPresent[index] and (queueSizes[index]>0) then
   begin
    if (curTime>=serviceTimes[index,0]) then
     removeCustomer(index);
   end;
  end;
     
  writeln('#waiting: '+str(numWaiting)+', wait time: '+str(maxServiceTime-curTime));
  update;
  pause(200);
 { Until all queues are full }
 until (abs(?key)=\escape) or (numWaiting>=numTellersPresent*maxQueueSize);
END.
